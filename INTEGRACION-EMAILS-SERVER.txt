üìß INTEGRACI√ìN DE EMAILS EN SERVER.JS
==========================================

‚ö†Ô∏è IMPORTANTE: Estos son los cambios que debes hacer en backend/server.js

==========================================
1. IMPORTAR EL SERVICIO DE EMAILS AL INICIO
==========================================

A√±ade esta l√≠nea despu√©s de las otras importaciones (l√≠nea ~10):

const emailService = require('./email-service');


==========================================
2. WEBHOOK: invoice.payment_succeeded
==========================================

Busca el case 'invoice.payment_succeeded' y a√±ade DESPU√âS de crear el cliente:

// Enviar email de bienvenida
await emailService.sendEmail('welcome', {
    email: customerEmail,
    full_name: `${account_first_name} ${account_last_name}`,
    first_name: account_first_name,
    business_name: submission?.business_name || 'tu empresa'
});

// Enviar email de confirmaci√≥n de pago
await emailService.sendEmail('payment-success', {
    email: customerEmail,
    full_name: `${account_first_name} ${account_last_name}`,
    plan,
    payment_date: new Date().toLocaleDateString('es-ES')
});

// Notificar al admin
await emailService.sendEmail('admin-new-client', {
    email: customerEmail,
    full_name: `${account_first_name} ${account_last_name}`,
    business_name: submission?.business_name || 'Sin nombre',
    plan
});

await emailService.sendEmail('admin-new-payment', {
    client: {
        full_name: `${account_first_name} ${account_last_name}`,
        email: customerEmail,
        plan
    },
    amount: (subscription.items.data[0].price.unit_amount / 100).toFixed(2)
});


==========================================
3. WEBHOOK: invoice.payment_failed
==========================================

Busca el case 'invoice.payment_failed' y A√ëADE este case completo:

case 'invoice.payment_failed':
    const failedInvoice = event.data.object;
    const attemptCount = failedInvoice.attempt_count;
    
    console.log(`‚ùå [WEBHOOK] Pago fallido - Intento ${attemptCount}/3`);
    
    try {
        // Buscar cliente por customer ID de Stripe
        const failedClientResult = await db.pool.query(
            'SELECT * FROM clients WHERE stripe_customer_id = $1',
            [failedInvoice.customer]
        );
        
        if (failedClientResult.rows.length > 0) {
            const client = failedClientResult.rows[0];
            
            // Enviar email al cliente seg√∫n el n√∫mero de intento
            await emailService.sendEmail('payment-failed', {
                client: {
                    email: client.email,
                    full_name: client.full_name,
                    plan: client.plan,
                    failure_reason: failedInvoice.last_payment_error?.message || 'Fondos insuficientes'
                },
                attemptNumber: attemptCount
            });
            
            // Notificar al admin
            await emailService.sendEmail('admin-payment-failed', {
                client: {
                    email: client.email,
                    full_name: client.full_name,
                    plan: client.plan,
                    failure_reason: failedInvoice.last_payment_error?.message || 'Fondos insuficientes'
                },
                attemptNumber: attemptCount
            });
            
            console.log(`‚úÖ [WEBHOOK] Emails de pago fallido enviados (intento ${attemptCount})`);
        }
    } catch (error) {
        console.error('‚ùå [WEBHOOK] Error procesando pago fallido:', error);
    }
    break;


==========================================
4. WEBHOOK: customer.subscription.deleted
==========================================

Busca el case 'customer.subscription.deleted' y a√±ade DESPU√âS de actualizar la BD:

// Enviar email de servicio suspendido
if (client) {
    await emailService.sendEmail('service-suspended', {
        email: client.email,
        full_name: client.full_name,
        business_name: client.business_name
    });
}


==========================================
5. WEBHOOK: customer.subscription.updated (CANCELACI√ìN)
==========================================

Busca donde se detecta cancel_at_period_end === true y a√±ade DESPU√âS de actualizar:

// Enviar email de cancelaci√≥n
await emailService.sendEmail('subscription-cancelled', {
    email: client.email,
    full_name: client.full_name,
    subscription_end_date: endDate.toLocaleDateString('es-ES', { 
        day: 'numeric', 
        month: 'long', 
        year: 'numeric' 
    })
});


==========================================
6. ENDPOINT: Activar web (cuando el admin entrega)
==========================================

Busca el endpoint PUT /api/client/website-status/:clientId y a√±ade DESPU√âS de actualizar:

// Enviar email de web entregada
const client = await db.getClientById(clientId);
if (client && status === 'activo') {
    await emailService.sendEmail('website-delivered', {
        email: client.email,
        full_name: client.full_name,
        business_name: client.business_name,
        website_url: client.website_url,
        wordpress_url: client.wordpress_url,
        wordpress_username: client.wordpress_username,
        wordpress_password: client.wordpress_password
    });
}


==========================================
7. ENDPOINT: Admin responde a ticket
==========================================

Busca el endpoint PATCH /api/tickets/:ticketId (donde el admin responde) y a√±ade:

// Enviar email al cliente
const ticket = await db.getTicketById(ticketId);
const client = await db.getClientById(ticket.client_id);

if (client && admin_response) {
    await emailService.sendEmail('ticket-response', {
        client: {
            email: client.email,
            full_name: client.full_name
        },
        ticket: {
            id: ticketId,
            subject: ticket.subject,
            admin_response: admin_response
        }
    });
}


==========================================
8. ENDPOINT: Nuevo ticket creado
==========================================

Busca el endpoint POST /api/tickets y a√±ade DESPU√âS de crear el ticket:

// Notificar al admin
const createdTicket = await db.getTicketById(ticketId);
await emailService.sendEmail('admin-new-ticket', {
    client: {
        full_name: data.client_name,
        email: data.client_email
    },
    ticket: {
        id: ticketId,
        subject: data.subject,
        category: data.category,
        priority: data.priority,
        description: data.description
    }
});


==========================================
9. FUNCI√ìN AUTOM√ÅTICA: Recordatorios de renovaci√≥n
==========================================

A√±ade esta funci√≥n NUEVA al final del archivo (antes de module.exports):

// Funci√≥n para enviar recordatorios de renovaci√≥n
async function sendRenewalReminders() {
    try {
        const now = new Date();
        const clients = await db.getAllClients();
        
        for (const client of clients) {
            if (client.payment_date && client.subscription_status === 'active') {
                const paymentDate = new Date(client.payment_date);
                const nextBilling = new Date(paymentDate);
                nextBilling.setDate(nextBilling.getDate() + 30); // Asumiendo renovaci√≥n mensual
                
                const daysUntilRenewal = Math.ceil((nextBilling - now) / (1000 * 60 * 60 * 24));
                
                // Enviar recordatorios a los 7, 3 y 1 d√≠as
                if ([7, 3, 1].includes(daysUntilRenewal)) {
                    await emailService.sendEmail('renewal-reminder', {
                        client: {
                            email: client.email,
                            full_name: client.full_name,
                            next_billing_date: nextBilling.toLocaleDateString('es-ES'),
                            plan_price: client.plan === 'basico' ? '35‚Ç¨' : 
                                       client.plan === 'avanzado' ? '49‚Ç¨' : '65‚Ç¨'
                        },
                        daysLeft: daysUntilRenewal
                    });
                    
                    console.log(`‚úÖ Recordatorio de renovaci√≥n enviado a ${client.email} (${daysUntilRenewal} d√≠as)`);
                }
            }
        }
    } catch (error) {
        console.error('‚ùå Error enviando recordatorios:', error);
    }
}

// Ejecutar recordatorios cada 12 horas
setInterval(sendRenewalReminders, 12 * 60 * 60 * 1000);


==========================================
10. RESUMEN DE TRIGGERS
==========================================

‚úÖ EMAILS AL CLIENTE:
1. Bienvenida ‚Üí Despu√©s de registrarse y pagar
2. Confirmaci√≥n de pago ‚Üí Despu√©s de pagar
3. Web entregada ‚Üí Cuando admin activa la web
4. Respuesta a ticket ‚Üí Cuando admin responde
5. Recordatorios (7,3,1 d√≠as) ‚Üí Autom√°tico cada 12h
6. Pago fallido (1,2,3 intentos) ‚Üí Webhook de Stripe
7. Servicio suspendido ‚Üí Webhook de Stripe
8. Suscripci√≥n cancelada ‚Üí Webhook de Stripe

‚úÖ EMAILS AL ADMIN:
1. Nuevo cliente ‚Üí Despu√©s del pago
2. Nuevo pago ‚Üí Despu√©s del pago
3. Nuevo ticket ‚Üí Al crear ticket
4. Pago fallido ‚Üí Webhook de Stripe
5. Cliente suspendido ‚Üí Webhook de Stripe


==========================================
NOTA FINAL
==========================================

‚ö†Ô∏è Despu√©s de hacer estos cambios:
1. Guarda server.js
2. Haz commit y push
3. Railway redeployar√° autom√°ticamente
4. Los emails empezar√°n a enviarse autom√°ticamente

üéâ ¬°Sistema completo de emails configurado!

